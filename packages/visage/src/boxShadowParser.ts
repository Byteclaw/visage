// tslint:disable:only-arrow-functions
// tslint:disable:object-literal-shorthand
// tslint:disable:trailing-comma
// tslint:disable:object-literal-sort-keys
// tslint:disable:one-variable-per-declaration
// tslint:disable:max-line-length
// tslint:disable:no-consecutive-blank-lines
// tslint:disable:align

// Generated by PEG.js v. 0.10.0 (ts-pegjs plugin v. 0.2.6 )
//
// https://pegjs.org/   https://github.com/metadevpro/ts-pegjs

export interface IFilePosition {
  offset: number;
  line: number;
  column: number;
}

export interface IFileRange {
  start: IFilePosition;
  end: IFilePosition;
}

export interface ILiteralExpectation {
  type: 'literal';
  text: string;
  ignoreCase: boolean;
}

export interface IClassParts extends Array<string | IClassParts> {}

export interface IClassExpectation {
  type: 'class';
  parts: IClassParts;
  inverted: boolean;
  ignoreCase: boolean;
}

export interface IAnyExpectation {
  type: 'any';
}

export interface IEndExpectation {
  type: 'end';
}

export interface IOtherExpectation {
  type: 'other';
  description: string;
}

export type Expectation =
  | ILiteralExpectation
  | IClassExpectation
  | IAnyExpectation
  | IEndExpectation
  | IOtherExpectation;

export class SyntaxError extends Error {
  public static buildMessage(expected: Expectation[], found: string | null) {
    function hex(ch: string): string {
      return ch.charCodeAt(0).toString(16).toUpperCase();
    }

    function literalEscape(s: string): string {
      return s
        .replace(/\\/g, '\\\\')
        .replace(/"/g, '\\"')
        .replace(/\0/g, '\\0')
        .replace(/\t/g, '\\t')
        .replace(/\n/g, '\\n')
        .replace(/\r/g, '\\r')
        .replace(/[\x00-\x0F]/g, ch => `\\x0${hex(ch)}`)
        .replace(/[\x10-\x1F\x7F-\x9F]/g, ch => `\\x${hex(ch)}`);
    }

    function classEscape(s: string): string {
      return s
        .replace(/\\/g, '\\\\')
        .replace(/\]/g, '\\]')
        .replace(/\^/g, '\\^')
        .replace(/-/g, '\\-')
        .replace(/\0/g, '\\0')
        .replace(/\t/g, '\\t')
        .replace(/\n/g, '\\n')
        .replace(/\r/g, '\\r')
        .replace(/[\x00-\x0F]/g, ch => `\\x0${hex(ch)}`)
        .replace(/[\x10-\x1F\x7F-\x9F]/g, ch => `\\x${hex(ch)}`);
    }

    function describeExpectation(expectation: Expectation) {
      switch (expectation.type) {
        case 'literal':
          return `"${literalEscape(expectation.text)}"`;
        case 'class':
          const escapedParts = expectation.parts.map(part => {
            return Array.isArray(part)
              ? `${classEscape(part[0] as string)}-${classEscape(
                  part[1] as string,
                )}`
              : classEscape(part);
          });

          return `[${expectation.inverted ? '^' : ''}${escapedParts}]`;
        case 'any':
          return 'any character';
        case 'end':
          return 'end of input';
        case 'other':
          return expectation.description;
      }
    }

    function describeExpected(expected1: Expectation[]) {
      const descriptions = expected1.map(describeExpectation);
      let i: number;
      let j: number;

      descriptions.sort();

      if (descriptions.length > 0) {
        for (i = 1, j = 1; i < descriptions.length; i++) {
          if (descriptions[i - 1] !== descriptions[i]) {
            descriptions[j] = descriptions[i];
            j++;
          }
        }
        descriptions.length = j;
      }

      switch (descriptions.length) {
        case 1:
          return descriptions[0];

        case 2:
          return `${descriptions[0]} or ${descriptions[1]}`;

        default:
          return `${descriptions.slice(0, -1).join(', ')}, or ${
            descriptions[descriptions.length - 1]
          }`;
      }
    }

    function describeFound(found1: string | null) {
      return found1 ? `"${literalEscape(found1)}"` : 'end of input';
    }

    return `Expected ${describeExpected(expected)} but ${describeFound(
      found,
    )} found.`;
  }

  public message: string;

  public expected: Expectation[];

  public found: string | null;

  public location: IFileRange;

  public name: string;

  constructor(
    message: string,
    expected: Expectation[],
    found: string | null,
    location: IFileRange,
  ) {
    super();
    this.message = message;
    this.expected = expected;
    this.found = found;
    this.location = location;
    this.name = 'SyntaxError';

    if (typeof (Error as any).captureStackTrace === 'function') {
      (Error as any).captureStackTrace(this, SyntaxError);
    }
  }
}

function peg$parse(input: string, options?: IParseOptions) {
  options = options !== undefined ? options : {};

  const peg$FAILED: Readonly<{}> = {};

  const peg$startRuleIndices: { [id: string]: number } = { start: 0 };
  let peg$startRuleIndex = 0;

  const peg$consts = [
    'none',
    peg$literalExpectation('none', false),
    'initial',
    peg$literalExpectation('initial', false),
    'inherit',
    peg$literalExpectation('inherit', false),
    'unset',
    peg$literalExpectation('unset', false),
    function (bss: any): any {
      return bss;
    },
    'inset',
    peg$literalExpectation('inset', false),
    function (col: any): any {
      return { color: col };
    },
    'rgb',
    peg$literalExpectation('rgb', false),
    'hsl',
    peg$literalExpectation('hsl', false),
    'a',
    peg$literalExpectation('a', false),
    '(',
    peg$literalExpectation('(', false),
    ')',
    peg$literalExpectation(')', false),
    'color(',
    peg$literalExpectation('color(', false),
    '#',
    peg$literalExpectation('#', false),
    /^[a-zA-Z]/,
    peg$classExpectation(
      [
        ['a', 'z'],
        ['A', 'Z'],
      ],
      false,
      false,
    ),
    '.',
    peg$literalExpectation('.', false),
    '-',
    peg$literalExpectation('-', false),
    /^[0-9]/,
    peg$classExpectation([['0', '9']], false, false),
    /^[a-z]/,
    peg$classExpectation([['a', 'z']], false, false),
    '+',
    peg$literalExpectation('+', false),
    'if(',
    peg$literalExpectation('if(', false),
    'ifDark',
    peg$literalExpectation('ifDark', false),
    'ifLight',
    peg$literalExpectation('ifLight', false),
    'blenda',
    peg$literalExpectation('blenda', false),
    'blend',
    peg$literalExpectation('blend', false),
    /^[0-9a-fA-F]/,
    peg$classExpectation(
      [
        ['0', '9'],
        ['a', 'f'],
        ['A', 'F'],
      ],
      false,
      false,
    ),
    '%',
    peg$literalExpectation('%', false),
    peg$otherExpectation('whitespace'),
    /^[ \t\n\r,]/,
    peg$classExpectation([' ', '\t', '\n', '\r', ','], false, false),
  ];

  const peg$bytecode = [
    peg$decode(
      '2 ""6 7!.` &2"""6"7#.T &2$""6$7%.H &2&""6&7\'.< &%$;!/&#0#*;!&&&#/\' 8!:(!! )',
    ),
    peg$decode(';".) &;#.# &;$'),
    peg$decode(
      "%;3/\x96#2)\"\"6)7*.\" &\"/\x82$;3/y$;*/p$;3/g$;*/^$;3/U$;*/L$;3/C$;*/:$;3/1$;%/($8,:+,! )(,'#(+'#(*'#()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#",
    ),
    peg$decode(
      "%;3/\x84#2)\"\"6)7*.\" &\"/p$;3/g$;*/^$;3/U$;*/L$;3/C$;*/:$;3/1$;%/($8*:+*! )(*'#()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#",
    ),
    peg$decode(
      "%;3/r#2)\"\"6)7*.\" &\"/^$;3/U$;*/L$;3/C$;*/:$;3/1$;%/($8(:+(! )(('#(''#(&'#(%'#($'#(#'#(\"'#&'#",
    ),
    peg$decode('%;\'./ &;&.) &;(.# &;)/"!&,)'),
    peg$decode(
      '%2,""6,7-.) &2.""6.7//\xAB#20""6071." &"/\x97$22""6273/\x88$;3/\x7F$;2/v$;3/m$;2/d$;3/[$;2/R$;3/I$;0." &"/;$;3/2$24""6475/#$+-)(-\'#(,\'#(+\'#(*\'#()\'#((\'#(\'\'#(&\'#(%\'#($\'#(#\'#("\'#&\'#',
    ),
    peg$decode(
      "%26\"\"6677/f#;3/]$;%/T$;3/K$$;+0#*;+&/;$;3/2$24\"\"6475/#$+')(''#(&'#(%'#($'#(#'#(\"'#&'#",
    ),
    peg$decode(
      "%28\"\"6879/\x85#%;//P#;//G$;//>$;//5$;//,$;//#$+&)(&'#(%'#($'#(#'#(\"'#&'#.? &%;//5#;//,$;//#$+#)(#'#(\"'#&'#/#$+\")(\"'#&'#",
    ),
    peg$decode(
      '%%$4:""5!7;/,#0)*4:""5!7;&&&#/w#%2<""6<7=/Y#2>""6>7?." &"/E$$4@""5!7A/,#0)*4@""5!7A&&&#/#$+#)(#\'#("\'#&\'#." &"/#$+")("\'#&\'#/"!&,)',
    ),
    peg$decode(
      '%%2>""6>7?." &"/,#;0/#$+")("\'#&\'#.U &%2<""6<7=/E#$4@""5!7A/,#0)*4@""5!7A&&&#/#$+")("\'#&\'#/?#$4:""5!7;0)*4:""5!7;&/#$+")("\'#&\'#',
    ),
    peg$decode("%;3/A#;-.) &;..# &;,/,$;3/#$+#)(#'#(\"'#&'#"),
    peg$decode(
      '%$4B""5!7C/,#0)*4B""5!7C&&&#/\x8A#22""6273/{$;3/r$2D""6D7E.) &2>""6>7?." &"/R$;3/I$;2." &"/;$;3/2$24""6475/#$+()((\'#(\'\'#(&\'#(%\'#($\'#(#\'#("\'#&\'#',
    ),
    peg$decode(
      "%2F\"\"6F7G/\xB3#;3/\xAA$$4:\"\"5!7;/,#0)*4:\"\"5!7;&&&#/\x88$;3/\x7F$;'./ &;&.) &;(.# &;)/d$;3/[$;'./ &;&.) &;(.# &;).\" &\"/;$;3/2$24\"\"6475/#$+))()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#",
    ),
    peg$decode(
      '%2H""6H7I.A &2J""6J7K.5 &2L""6L7M.) &2N""6N7O/\x85#22""6273/v$;3/m$;\'./ &;&.) &;(.# &;)/R$;3/I$;1." &"/;$;3/2$24""6475/#$+()((\'#(\'\'#(&\'#(%\'#($\'#(#\'#("\'#&\'#',
    ),
    peg$decode('4P""5!7Q'),
    peg$decode(
      '%$4@""5!7A/,#0)*4@""5!7A&&&#/c#%2<""6<7=/E#$4@""5!7A/,#0)*4@""5!7A&&&#/#$+")("\'#&\'#." &"/#$+")("\'#&\'#',
    ),
    peg$decode('%;0/2#2R""6R7S/#$+")("\'#&\'#'),
    peg$decode(';1.# &;0'),
    peg$decode('<$4U""5!7V0)*4U""5!7V&=." 7T'),
  ];

  let peg$currPos = 0;
  let peg$savedPos = 0;
  const peg$posDetailsCache = [{ line: 1, column: 1 }];
  let peg$maxFailPos = 0;
  let peg$maxFailExpected: Expectation[] = [];
  let peg$silentFails = 0;

  let peg$result;

  if (options.startRule !== undefined) {
    if (!(options.startRule in peg$startRuleIndices)) {
      throw new Error(`Can't start parsing from rule "${options.startRule}".`);
    }

    peg$startRuleIndex = peg$startRuleIndices[options.startRule];
  }

  function text(): string {
    return input.substring(peg$savedPos, peg$currPos);
  }

  function location(): IFileRange {
    return peg$computeLocation(peg$savedPos, peg$currPos);
  }

  function expected(description: string, location1?: IFileRange) {
    location1 =
      location1 !== undefined
        ? location1
        : peg$computeLocation(peg$savedPos, peg$currPos);

    throw peg$buildStructuredError(
      [peg$otherExpectation(description)],
      input.substring(peg$savedPos, peg$currPos),
      location1,
    );
  }

  function error(message: string, location1?: IFileRange) {
    location1 =
      location1 !== undefined
        ? location1
        : peg$computeLocation(peg$savedPos, peg$currPos);

    throw peg$buildSimpleError(message, location1);
  }

  function peg$literalExpectation(
    text1: string,
    ignoreCase: boolean,
  ): ILiteralExpectation {
    return { type: 'literal', text: text1, ignoreCase };
  }

  function peg$classExpectation(
    parts: IClassParts,
    inverted: boolean,
    ignoreCase: boolean,
  ): IClassExpectation {
    return {
      type: 'class',
      parts,
      inverted,
      ignoreCase,
    };
  }

  function peg$anyExpectation(): IAnyExpectation {
    return { type: 'any' };
  }

  function peg$endExpectation(): IEndExpectation {
    return { type: 'end' };
  }

  function peg$otherExpectation(description: string): IOtherExpectation {
    return { type: 'other', description };
  }

  function peg$computePosDetails(pos: number) {
    let details = peg$posDetailsCache[pos];
    let p;

    if (details) {
      return details;
    }
    p = pos - 1;
    while (!peg$posDetailsCache[p]) {
      p--;
    }

    details = peg$posDetailsCache[p];
    details = {
      line: details.line,
      column: details.column,
    };

    while (p < pos) {
      if (input.charCodeAt(p) === 10) {
        details.line++;
        details.column = 1;
      } else {
        details.column++;
      }

      p++;
    }

    peg$posDetailsCache[pos] = details;

    return details;
  }

  function peg$computeLocation(startPos: number, endPos: number): IFileRange {
    const startPosDetails = peg$computePosDetails(startPos);
    const endPosDetails = peg$computePosDetails(endPos);

    return {
      start: {
        offset: startPos,
        line: startPosDetails.line,
        column: startPosDetails.column,
      },
      end: {
        offset: endPos,
        line: endPosDetails.line,
        column: endPosDetails.column,
      },
    };
  }

  function peg$fail(expected1: Expectation) {
    if (peg$currPos < peg$maxFailPos) {
      return;
    }

    if (peg$currPos > peg$maxFailPos) {
      peg$maxFailPos = peg$currPos;
      peg$maxFailExpected = [];
    }

    peg$maxFailExpected.push(expected1);
  }

  function peg$buildSimpleError(message: string, location1: IFileRange) {
    return new SyntaxError(message, [], '', location1);
  }

  function peg$buildStructuredError(
    expected1: Expectation[],
    found: string | null,
    location1: IFileRange,
  ) {
    return new SyntaxError(
      SyntaxError.buildMessage(expected1, found),
      expected1,
      found,
      location1,
    );
  }

  function peg$decode(s: string): number[] {
    return s.split('').map(ch => ch.charCodeAt(0) - 32);
  }

  function peg$parseRule(index: number): any {
    const bc = peg$bytecode[index];
    let ip = 0;
    const ips: any[] = [];
    let end = bc.length;
    const ends: any[] = [];
    const stack: any[] = [];
    let params;

    while (true) {
      while (ip < end) {
        switch (bc[ip]) {
          case 0:
            stack.push(peg$consts[bc[ip + 1]]);
            ip += 2;
            break;

          case 1:
            stack.push(undefined);
            ip++;
            break;

          case 2:
            stack.push(null);
            ip++;
            break;

          case 3:
            stack.push(peg$FAILED);
            ip++;
            break;

          case 4:
            stack.push([]);
            ip++;
            break;

          case 5:
            stack.push(peg$currPos);
            ip++;
            break;

          case 6:
            stack.pop();
            ip++;
            break;

          case 7:
            peg$currPos = stack.pop();
            ip++;
            break;

          case 8:
            stack.length -= bc[ip + 1];
            ip += 2;
            break;

          case 9:
            stack.splice(-2, 1);
            ip++;
            break;

          case 10:
            stack[stack.length - 2].push(stack.pop());
            ip++;
            break;

          case 11:
            stack.push(stack.splice(stack.length - bc[ip + 1], bc[ip + 1]));
            ip += 2;
            break;

          case 12:
            stack.push(input.substring(stack.pop(), peg$currPos));
            ip++;
            break;

          case 13:
            ends.push(end);
            ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);

            if (stack[stack.length - 1]) {
              end = ip + 3 + bc[ip + 1];
              ip += 3;
            } else {
              end = ip + 3 + bc[ip + 1] + bc[ip + 2];
              ip += 3 + bc[ip + 1];
            }

            break;

          case 14:
            ends.push(end);
            ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);

            if (stack[stack.length - 1] === peg$FAILED) {
              end = ip + 3 + bc[ip + 1];
              ip += 3;
            } else {
              end = ip + 3 + bc[ip + 1] + bc[ip + 2];
              ip += 3 + bc[ip + 1];
            }

            break;

          case 15:
            ends.push(end);
            ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);

            if (stack[stack.length - 1] !== peg$FAILED) {
              end = ip + 3 + bc[ip + 1];
              ip += 3;
            } else {
              end = ip + 3 + bc[ip + 1] + bc[ip + 2];
              ip += 3 + bc[ip + 1];
            }

            break;

          case 16:
            if (stack[stack.length - 1] !== peg$FAILED) {
              ends.push(end);
              ips.push(ip);

              end = ip + 2 + bc[ip + 1];
              ip += 2;
            } else {
              ip += 2 + bc[ip + 1];
            }

            break;

          case 17:
            ends.push(end);
            ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);

            if (input.length > peg$currPos) {
              end = ip + 3 + bc[ip + 1];
              ip += 3;
            } else {
              end = ip + 3 + bc[ip + 1] + bc[ip + 2];
              ip += 3 + bc[ip + 1];
            }

            break;

          case 18:
            ends.push(end);
            ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);

            if (
              input.substr(
                peg$currPos,
                (peg$consts[bc[ip + 1]] as string).length,
              ) === peg$consts[bc[ip + 1]]
            ) {
              end = ip + 4 + bc[ip + 2];
              ip += 4;
            } else {
              end = ip + 4 + bc[ip + 2] + bc[ip + 3];
              ip += 4 + bc[ip + 2];
            }

            break;

          case 19:
            ends.push(end);
            ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);

            if (
              input
                .substr(peg$currPos, (peg$consts[bc[ip + 1]] as string).length)
                .toLowerCase() === peg$consts[bc[ip + 1]]
            ) {
              end = ip + 4 + bc[ip + 2];
              ip += 4;
            } else {
              end = ip + 4 + bc[ip + 2] + bc[ip + 3];
              ip += 4 + bc[ip + 2];
            }

            break;

          case 20:
            ends.push(end);
            ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);

            if (
              (peg$consts[bc[ip + 1]] as RegExp).test(input.charAt(peg$currPos))
            ) {
              end = ip + 4 + bc[ip + 2];
              ip += 4;
            } else {
              end = ip + 4 + bc[ip + 2] + bc[ip + 3];
              ip += 4 + bc[ip + 2];
            }

            break;

          case 21:
            stack.push(input.substr(peg$currPos, bc[ip + 1]));
            peg$currPos += bc[ip + 1];
            ip += 2;
            break;

          case 22:
            stack.push(peg$consts[bc[ip + 1]]);
            peg$currPos += (peg$consts[bc[ip + 1]] as string).length;
            ip += 2;
            break;

          case 23:
            stack.push(peg$FAILED);
            if (peg$silentFails === 0) {
              peg$fail(peg$consts[bc[ip + 1]] as ILiteralExpectation);
            }
            ip += 2;
            break;

          case 24:
            peg$savedPos = stack[stack.length - 1 - bc[ip + 1]];
            ip += 2;
            break;

          case 25:
            peg$savedPos = peg$currPos;
            ip++;
            break;

          case 26:
            params = bc.slice(ip + 4, ip + 4 + bc[ip + 3]).map(function (p) {
              return stack[stack.length - 1 - p];
            });

            stack.splice(
              stack.length - bc[ip + 2],
              bc[ip + 2],
              (peg$consts[bc[ip + 1]] as (...args: any[]) => any).apply(
                null,
                params,
              ),
            );

            ip += 4 + bc[ip + 3];
            break;

          case 27:
            stack.push(peg$parseRule(bc[ip + 1]));
            ip += 2;
            break;

          case 28:
            peg$silentFails++;
            ip++;
            break;

          case 29:
            peg$silentFails--;
            ip++;
            break;

          default:
            throw new Error(`Invalid opcode: ${bc[ip]}.`);
        }
      }

      if (ends.length > 0) {
        end = ends.pop();
        ip = ips.pop();
      } else {
        break;
      }
    }

    return stack[0];
  }

  peg$result = peg$parseRule(peg$startRuleIndex);

  if (peg$result !== peg$FAILED && peg$currPos === input.length) {
    return peg$result;
  }
  if (peg$result !== peg$FAILED && peg$currPos < input.length) {
    peg$fail(peg$endExpectation());
  }

  throw peg$buildStructuredError(
    peg$maxFailExpected,
    peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
    peg$maxFailPos < input.length
      ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
      : peg$computeLocation(peg$maxFailPos, peg$maxFailPos),
  );
}

export interface IParseOptions {
  filename?: string;
  startRule?: string;
  tracer?: any;
  [key: string]: any;
}
export type ParseFunction = (input: string, options?: IParseOptions) => any;
export const parse: ParseFunction = peg$parse;
